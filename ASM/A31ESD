//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M
//*
//* First modify JOB card and data set names to your environment
//* Assemble and Link program/module
//*
//ASMH EXEC PGM=ASMA90,REGION=4M,
// PARM='OBJECT,NODECK,NOXREF,BATCH,RENT'
//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST   <== hlq.MACLIB
//         DD DISP=SHR,DSN=SYS1.MACLIB
//         DD DISP=SHR,DSN=SYS1.MODGEN
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//SYSIN    DD *
         TITLE 'A31ESD - Name Area Initialization in A31TABS'
*---------------------------------------------------------------------
* 04/22/03 SVM Added fields to PTAB, changed PDS entry processing
* 04/02/03 SVM Re-created from BV.A31ESD for amode=31
*
* Reads ESD, RLD and SYM records from load module,
* Crates and inits tables: CTAB, DTAB and NTAB inside PTAB area
* All P#AREA from old PTAB are considered empty.
*
* Use from PL/I:
* CALL A31ESD(D#,PTAB); OPTIONS(ASM INTER RETCODE)
* In:   R1->list of 2 addresses (C VL),
*       A1=Addr of parm (D#) block for $OPEN,
*       A2=Addr of PTAB area to be filled with the program data.
*       (see IRXF@PGM for example of use)
*
* Out:   R15=0-normal
*            4-No SYM, NTAB contains entries for CSECT and EP only
*            8-OVLY program - not supported
*           12-No ESD, CTAB contains dummy entry for the program,
*              NTAB contains entry for EP at offset 0.
*           16-Error when OPEN load library
*           20-RAM shortage
*           24-Cannot LOAD EP=$OPENI
*
* Reentrant, LOADs and CALLs $OPEN to access load library.
*---------------------------------------------------------------------
         YREGS
A31ESD   BEGIN
$WRK     WORK  LV=$WRKLEN,LOC=BELOW
         B     START
*
EXIT     L     R3,A$OPEN
         LTR   R3,R3
         BZ    FINX
         DELETE EP=$OPENI
         LTR   R15,R15
         BZ    FINX
**       WTO   'A31ESD: DELETE EP=$OPENI failed',ROUTCDE=11
FINX     L     R15,RC
         FIN
*
START    XC    A$OPEN,A$OPEN
         XC    RC,RC
         MVC   PARMLIST(8),0(R1)       Copy Parameter list
         OI    PARMLIST,VL             Set VL for $OPEN
**       LA    R2,PARMLIST             Switch to the copy
*---------------------------------------------------------------------*
*-                                                                    *
*---------------------------------------------------------------------*
**       LOAD  EP=A3CVT
**       LR    3,0
**       IC    3,C#FLAGS(3)
**       STC   3,W#DEBUG
*        WTO   'A31ESD: Calling $OPENI...',ROUTCDE=11
         LOAD  EP=$OPENI,ERRET=LOADERR
         ST    R0,A$OPEN
         LR    R1,R0
         LA    R0,$CLSOFFS(R1)
         ST    R0,A$CLOSE
         LA    R0,$REDOFFS(R1)
         ST    R0,A$READ
*
         MVI   RC+3,NOTOPEN
         LA    R1,PARMLIST             Restore R1
         L     R15,A$OPEN
         BASSM R14,R15                 ***> CALL $OPEN
         LTR   R15,R15
         BZ    GOODOPEN                $OPEN good
*- OPEN failed:
*        WTO   'A31ESD: OPEN FAILED',ROUTCDE=11  *** DEBUG ***
         MVI   RC+3,NOTOPEN
         B     EXIT
*- LOAD failed:
LOADERR  DS    0H
         WTO   'LOAD EP=$OPEN failed',ROUTCDE=11
         MVI   RC+3,NO$OPEN
         B     EXIT
*- OPEN GOOD: Init PTAB, if empty (except P#NEXT & P#ADDR):
GOODOPEN XC    SYMFOUND(4),SYMFOUND    Drop Flag of SYM presence
         MVI   RC+3,NOESD
         L     R11,PTABADDR            R11=Addr of PTAB
         USING PTAB,R11                Tell Assembler
         L     R10,D##ADDR             R10=Addr of D#
         USING D#,R10                  Tell Assembler
         L     R9,D#BUF                R9->Input buffer
         USING PDS24,R9
*
         MVC   OVERFL(4),=XL4'00FFFFFF' Mask "No overlay"
         TM    PDS2ATR1,PDS2OVLY       Ovly ?
         BNO   NOOVL                   No
         MVI   OVERFL,X'0F'            Mask "Overlay"
NOOVL    DS    0H
         MVC   P#SIZE+1(3),PDS2STOR    ==> P#SIZE=Program size
         MVC   P#ENTRY+1(3),PDS2EPA    ==> P#ENTRY=Addr of Entry
         MVC   P#NAME(8),D#MEM         ==> P#NAME=Program Name
         MVC   P#DSN,D#DSN             ==> P#DSN=Load lib name
         MVC   P#VOL,D#VOL             ==> P#VOL=Volser for lib
         MVC   P#ATR1(2),PDS2ATR1      ==> P#ATR1 and P#ATR2
         MVC   P#FLAG(1),PDS2FTB2      ==> P#FLAG = PDS2FTB2
         NI    P#FLAG,X'7F'            shut bit 0 (alias indicatior)
         MVC   P#ANAME(8),#BLANKS      clear
         XC    P#AENTRY(4),P#AENTRY    clear
*- Init service fields in PTAB:
         LA    3,P#DATA
         ST    3,P#AFREE               ==> P#AFREE-> Start of OBL.data
         SR    3,3
         ST    3,P#CTAB                ==> P#CTAB
*---------------------------------------------------------------------*
*-- Fields built by BLDL (ref IHAPDS + 4): mapping & processing:
*    basic section: 33 bytes                      present if:
*    SCTR section :  8 bytes (not supported here) PDS2ATR1=X'04'
*    Alias section: 11 bytes (alias only)         PDS2INDC=X'80'
*    SSI section  :  4 bytes (aligned to H)       PDS2FTB1=X'10'
*    APF section  :  2 bytes                      PDS2FTB1=X'08'
*    Large prog   : 19 bytes >16M, not supported  PDS2FTB1=X'40'
*---------------------------------------------------------------------*
*INDC     EQU   17                      Indicators PDS2INDC
*PDS2ATR  EQU   26                      Flags  in PDS
*SIZE     EQU   28                      Pgm size offset in PDS
*EPADDR   EQU   33                      Rel EP addr offset in PDS
*FTBO     EQU   36                      Flags
*AL3      EQU   39                      Alias sect
*SIWD     EQU   40                    ? SSI (3 bytes, if not alias)
*ASSI     EQU   50                    ? SSI (3 bytes, if alias)
         LA    R1,PDSS01               start of next (SCTR) sect ?
         TM    PDS2ATR1,PDS2SCTR       SCTR present ?
         BNO   NOSCTR1                 no
         LA    R1,PDSS01LN(R1)         advance position to alias sect
NOSCTR1  TM    PDS2INDC,PDS2ALIS       alias ?
         BNO   PROCSSI
*-- Process alias: replace P#NAME and P#ADDR by main program data:
         MVC   P#ANAME(8),P#NAME       ==> P#ANAME
         MVC   P#AENTRY(4),P#ENTRY     ==> P#AENTRY
     LR  3,1
     LR  1,3
         MVC   P#ENTRY+1(3),0(R1)      ==> P#ENTRY=Addr of main entry
         MVC   P#NAME(8),3(R1)         ==> P#NAME=Main Program Name
         OI    P#FLAG,X'80'            ==> indicate alias
         LA    R1,PDSS02LN(R1)         advance position to SSI sect
*-- Store SSI:  (usually overwritten by SSI from compiler records)
PROCSSI  TM    PDS2FTB1,PDS2SSI        SSI present?
         BNO   NOSSI                   No
         LA    R1,1(R1)                align pos to halfword:
         SRL   R1,1                    /2
         SLL   R1,1                    *2
         MVC   P#SSI(4),0(R1)          ==> P#SSI
         LA    R1,PDSS03LN(R1)         advance position to APF sect
*-- process APF:
NOSSI    XC    P#ACODE(1),P#ACODE      clear
         CLI   0(R1),X'00'             not present
         BE    LARGE                   no AC
         MVC   P#ACODE(1),1(R1)        ==> P#ACODE
*-- process large:
LARGE    LA    R1,PDSS04LN(R1)         advance position to large sect
         TM    PDS2FTB2,PDS2BIG        Large program sect present?
         BNO   CHKERR                  no
         MVC   P#SIZE(4),1(R1)         ==> P#SIZE
         MVC   P#ENTRY(4),5(R1)        ==> P#ENTRY
         TM    PDS2INDC,PDS2ALIS       alias ?
         BNO   CHKERR                  no
         MVC   P#AENTRY(4),9(R1)       ==> P#AENTRY
*-- indicate unsupported SCTR:
CHKERR   TM    PDS2ATR1,PDS2SCTR       if SCTR
         BO    ESDEND                  signal error if SCTR
*
*---------------------------------------------------------------------*
*- Process ESD: Store SCECT to CTAB,
*- Add NTAB element for each EP
*---------------------------------------------------------------------*
ESD      SR    6,6                     Current # of ESD element
*- Read block:
NEXTESD  LA    1,PARMLIST              Restore R1
         L     15,A$READ
         BASSM 14,15                   ***> CALL $READ
         LTR   15,15
         BNZ   ESDEND                  Probably IO error
         CLI   0(9),X'80'
         BE    ESDEND                  IDR: end of ESD & SYM records
         CLI   0(9),X'20'
         BE    PROCESD                 This is a ESD block
*- SYM?
         CLI   0(9),X'40'              Type SYM ?
         BNE   NEXTESD                 No
         MVI   SYMFOUND+3,1            Flag SYM present
         B     NEXTESD                 This block is not ESD
*- Process ESD block: R7=element counter
PROCESD  MVI   RC+3,NOSYM              Error expected
         LH    7,6(9)                  Block size (260)
         SRL   7,4                     How many elements in the block
         LA    8,8(9)                  Addr of the 1st element
         USING E#,8
*- Check the next ESD element:
TESTELM  LA    6,1(6)                  Element #
         NI    E#TYPE,X'0F'            Clear left half-byte of type
         SR    1,1
         IC    1,E#TYPE                type
         CH    1,=H'5'
         BH    NEXTELM                 type>5 (PR,NULL,WX)-> HE HAS TIP
         CH    1,=H'1'
         BE    NEXTELM                 TIP=1 (LD) - skip
         CH    1,=H'2'
         BE    NEXTELM                 TIP 2 (ER) - skip
         NC    E#SEG(4),OVERFL         Clear segm # if not Ovly
         TM    E#SEG,X'0E'             1 < Segment # < 16 - Ovly
         BZ    NOOVLY
         MVI   RC+3,OVERLAY            Skip overlay segments
         B     NEXTELM                 Error: OVERAY NOT SUPPORTED
*- Good - store as a new element:
NOOVLY   BAL   14,GETNEWC              R11->element CTAB
         B     ESDEND1                 If not available
         DROP  11                      USING
         USING CTAB,11
         XC    C#NTAB(4),C#NTAB        => C#NTAB
         XC    C#NEXT(4),C#NEXT        => C#NEXT
         STC   1,C#DTAB+3              => C#DTAB temp store type
         STC   1,C#TYPE                => C#TYPE
         L     1,LASTCTAB
         ST    11,0(1)                 Store addr of this CTAB
         LA    1,C#NEXT
         ST    1,LASTCTAB              Update LASTCTAB
         MVC   C#ADDR+1(3),E#ADDR      => C#ADDR
**chg    L     1,E#TYPE
**chg    LA    1,0(1)                  Addr
**chg    ST    1,C#ADDR                => C#ADDR
         MVC   C#DTAB(3),C#ADDR+1      C#DTAB = AL3(ADDR),XL1(TIP)
**                                     for sort
         MVC   C#NAME(8),E#NAME        => C#NAME
         MVC   C#SIZE+1(3),E#LEN       => C#SIZE
**chg    L     1,E#SEG
**chg    LA    1,0(1)                  Addr
**chg    ST    1,C#SIZE                => C#SIZE length
         ST    6,C#BASE                => C#BASE = Priv. # of element
*- Read next ESD element:
NEXTELM  LA    8,E#LENGTH(8)           Addr of next element
         BCT   7,TESTELM
*- Block end:
         B     NEXTESD
*- End of ESD:
ESDEND   CLI   RC+3,NOESD
         BNE   ESDEND1                 ESD records found
*- No ESD records: add a dummy CTAB:
         BAL   14,GETNEWC              R11->CTAB element
         B     ESDEND1                 Not available (?)
         DROP  11                      USING
         USING CTAB,11
         XC    C#NTAB(4),C#NTAB        => C#NTAB TIP1=0 (No names)
         XC    C#NEXT(4),C#NEXT        => C#NEXT
         XC    C#DTAB(4),C#DTAB        => C#DTAB TIP=CSECT (X'00')
         L     1,LASTCTAB
         ST    11,0(1)                 Store this CTAB addr
         LA    1,C#NEXT
         ST    1,LASTCTAB              Update LASTCTAB
         L     14,PTABADDR             Addr of PTAB
         USING PTAB,14
         MVC   C#ADDR(4),P#ENTRY       => C#ADDR
         MVC   C#NAME(8),P#NAME        => C#NAME
         MVC   C#SIZE(4),P#SIZE        => C#SIZE
         DROP  14                      USING
         XC    C#BASE(4),C#BASE        => C#BASE
         B     NSORT                   Complete processing
*---------------------------------------------------------------------*
*- Sort CTABS by C#DTAB, that means here
*- ascending by address (offset) and type
*---------------------------------------------------------------------*
ESDEND1  LR    9,11                    Last CTAB addr
         L     7,PTABADDR              PTAB
         USING PTAB,7                  Tell Assembler
         LA    6,P#CTAB                Addr of 1st reference
         DROP  7                       USING
         LR    8,11                    Addr of 1st CTAB
SORTRUN  SR    0,0                     exchange flag
         L     11,0(6)                 Take 1st CTAB
         LR    7,6                     Addr of 1st reference
NXTCTAB  L     10,C#NEXT               2nd = next
         LTR   10,10
         BZ    NXTPASS                 End of pass
         DROP  11                      USING
         USING CTAB,10
         L     1,C#DTAB                Addr + type in the next
         DROP  10                      USING
         USING CTAB,11
         C     1,C#DTAB                Compare to previous
         BL    EXCHANGE
         LA    7,C#NEXT                New previous
         LR    11,10                   1st = 2nd
         B     NXTCTAB
*- Exchange elements:
EXCHANGE ST    10,0(7)                 Ref to current
         DROP  11                      USING
         USING CTAB,10
         L     1,C#NEXT   ¢10!
         ST    11,C#NEXT  ¢10!         Ref from curren
         LA    7,C#NEXT   ¢10!         Addr of prev reference
         DROP  10                      USING
         USING CTAB,11
         ST    1,C#NEXT   ¢11!         reference from next
         LA    0,1                     exchange present?
         B     NXTCTAB                 11 now is 2nd
NXTPASS  LTR   0,0
         BZ    SORTEND                 No exchange
         B     SORTRUN
*=
SORTEND  DS    0H
*        WTO   'SORT ENDED',ROUTCDE=11
*---------------------------------------------------------------------*
*- Clean-up CTAB:
*- Clear C#DTAB, temp retain CSECT # in C#BASE,
*- For ENTRY place CTAB addr into C#DTAB,
*- For ENTRY (X'03') store CSECT addr to C#BASE
*---------------------------------------------------------------------*
         L     1,PTABADDR              PTAB addr
         USING PTAB,1
         L     1,P#CTAB                Addr of 1st CTAB
         DROP  1                       USING
         LR    11,1                    """"
         SR    0,0                     for type
CLRLOOP  DS    0H
         LTR   11,11
         BZ    CLREND                  End of pass
         XC    C#DTAB(4),C#DTAB        clear C#DTAB
**chg    L     0,C#DTAB                C#DTAB+3 = type
**chg    SLL   0,24                    Shift type to left byte
**chg    ST    0,C#DTAB                and store and clear C#DTAB
*- RLD:  XC    C#BASE(4),C#BASE        clear  C#BASE
         CLI   C#TYPE,LR               LABEL REFERENCE (Entry Point)
         BE    NXT#LR                  yes
*- CSECT: Store CTAB addr:
         LR    1,11                    Store Addr of CSECT.CTAB
         B     NXTCLR
*- Entry Point: Store CTAB of CSECT and size:
NXT#LR   DS    0H
**chg    O     1,C#DTAB                save type
         ST    1,C#DTAB                store addr of CSECT.CTAB
         DROP  11                      USING
         USING CTAB,1                  CSECT
         L     3,C#ADDR
         A     3,C#SIZE                Addr of end of CSECT
         DROP  1                       USING
         USING CTAB,11
         S     3,C#ADDR                Size from EP to the end
         ST    3,C#SIZE
NXTCLR   L     11,C#NEXT               2nd = next
         B     CLRLOOP
*-
         DROP  11                      USING
CLREND   CLI   SYMFOUND+3,1
         BNE   SYMENDX                 SYM not present
         CLI   RC+3,OVERLAY
         BE    GETSYM0                 RC set
         MVI   RC+3,0
GETSYM0  DS    0H
*        WTO   'SYM PROCESSING STARTED',ROUTCDE=11
*---------------------------------------------------------------------*
*                                                                     *
*- Fill NTAB chains for CSECT using SYM records,                      *
*- chains for DTAB and their chains for NTAB if any                   *
*                                                                     *
*---------------------------------------------------------------------*
*- Special use of R4:
*- R4=8 (NOESD) - Wrong CSECT
*- R4=0         - CSECT correct, wrong DSECT
*- R4=4 (NOSYM) - CSECT correct, wrong DSECT
         XC    ENDFILE,ENDFILE         End of File flag: EOF <> 0
         USING D#,10                   to access buffer
**       LA    2,PARMLIST
         L     10,D##ADDR              R10=Addr of D#
**       LA    10,0(10)                drop VL bit
GETSYM   SR    4,4
         LA    R1,PARMLIST
         L     15,A$OPEN
         BASSM 14,15                   ***> CALL  $OPEN
         L     9,D#BUF                 R9-> input block
         SR    6,6                     See NEXTELMS
NEXTBLK  LTR   6,6
         BZ    READ
*- Save remainder of SYM block:
         LA    7,S#REST
         EX    6,MVCS                  MVC 0(R6,R7),0(R5)
         LR    5,7                     Reset R5 to S#REST
READ     LA    R1,PARMLIST
         L     15,A$READ
         BASSM 14,15                   ***> CALL  $READ
         LTR   15,15
         BZ    CONTINUE
*-RLD :  MVI   RC+3,NOSYM              Unexpected end of SYM
         B     SYMEND
CONTINUE CLI   0(9),X'80'
         BE    SYMEND                  IDR - End of ESD & SYM
         CLI   0(9),X'40'
         BNE   NEXTBLK                 not a SYM-block
         CLI   1(9),X'00'
         BNE   NEXTBLK                 not a SYM-block
         DROP  8                       USING
         USING Y#,8                    Map SYM
         LA    8,4(9)                  Addr of 1st SYM card
         USING S#,7                    SYM element
*- R8-> start of SYM card
NEXTCARD LA    3,Y#LENGTH(8)           Addr of the end of new record
         S     3,D#BUF                 Length to the end of new record
         C     3,D#LAST                Length to the end of block
         BH    NEXTBLK                 Block exhosted
         CLC   Y#SYM(3),=C'SYM'
         BNE   NEWCARD                 Not a SYM(?) ...
         LA    7,Y#INF                 R7-> 1st SYM element
         MVC   Y#LENS(2),Y#LEN         Save Y#LEN
         B     NEXTELMS
NEWCARD  LA    8,Y#LENGTH(8)           Next card
         B     NEXTCARD
*- Prepare to analyse SYM element:
*- R6=length of prev remainder, R5=addr of remainder
*- If R6=0, attach the remander to the left
NEXTELMS LTR   6,6
         BZ    PROCELM                 No remainder
         SR    7,6
         BCTR  7,0                     New SYM element address
         EX    6,MVCS                  Attach remainder to the left
         SR    6,6                     and clear R6
*- R7-> SYM element
PROCELM  LA    5,S#NAME                R5 - pointer to current position
         MVI   SYMNAME,C' '
         MVC   SYMNAME+1(7),SYMNAME    Clear SYMNAME
*** debug
*        SAY   'SYM=',S#ORG,20
*
         CLI   S#ORG,X'68'
         BE    FIN2                    Skip EQU with no name
*
         TM    S#ORG,X'08'
         BO    GETOTHER                Unnamed element
GETNAME  SR    3,3
         IC    3,S#ORG
         SLL   3,29
         SRL   3,29                    R3 = name length - 1
         EX    3,MVCN                  Copy name to SYMNAME
         LA    5,1(3,5)                addr + length = next pos
**       LA    5,1(5)                  next position
GETOTHER SR    3,3
         ST    3,SYMKRATN              Default multiplier
         TM    S#ORG,X'80'
         BNO   NODATA                  Not data type
*- Element type data:
*- Detect type of data:
         SR    3,3
         IC    3,0(5)
         LR    14,3
         SRL   3,2                     type/4 = type # = I
         LA    15,SYMTYPE              Symbolic type names
         IC    3,0(3,15)               Select I-I type
         STC   3,SYMTYPE1              Store type to SYMTYPE1
         LA    5,1(5)                  next position
         CH    14,H9
         BL    LEN2                    length in 2 bytes:
*- Length in 1 byte:
         SR    3,3
         IC    3,0(5)                  R3 = length - 1
         LA    3,1(3)                  length
         STH   3,SYMLEN
         LA    5,1(5)
         B     KRATN
*- length in 2 bytes:
LEN2     SR    3,3
         IC    3,0(5)
         SLL   3,8
         IC    3,1(5)
         LA    3,1(3)                  length
         LA    5,2(5)
         STH   3,SYMLEN
*- Store multiplier if any:
KRATN    MVC   SYMKRATN(4),=F'1'       No multiplier - take 1
         TM    S#ORG,X'40'
         BNO   MAS                     no multiplier
         MVC   SYMKRATN+1(3),0(5)      Store multiplier
         LA    5,3(5)                  next position
*- Skip MACSTAB, if present:
MAS      TM    S#ORG,X'20'
         BNO   FIN#DATA                No MACSTAB
         LA    5,2(5)                  Skip MACSTAB
*- Skip data element if no name and multiplier = 0:
*- (like  DS 0H)
FIN#DATA CLI   SYMNAME,C' '
         BNE   FIN                     Name present
         L     3,SYMKRATN
         LTR   3,3
         BNZ   FIN                     Multiplier <> 0
         B     FIN2                    Skip element
*- Not data type convert type:
NODATA   SR    3,3
         IC    3,S#ORG
         SRL   3,4                     keep 4 bits
         STC   3,SYMTYPE1
         OI    SYMTYPE1,X'F0'
*
*- Non-data type: 1st 4 bits are X'F'
*        C'0'  blank
*        C'1'  CSECT
*        C'2'  DSECT
*        C'3'  COMMON
*        C'4'  machine instruction
*        C'5'  CCW
*        C'6'  relocatable EQU,
*              named LTORG,
*              named CNOP,
*              named ORG
         TM    S#ORG,X'70'
         BNZ   CMD                     not balnk
*- C'0' : blank:
         SR    3,3
         IC    3,0(5)                  length
         STH   3,SYMLEN
         LA    5,1(5)                  skip length
         B     FIN
*- CMD,CCW,EQU - element, make length zero because unknown:
CMD      SR    3,3
         STH   3,SYMLEN
         TM    S#ORG,X'40'
         BO    FIN                     not CSECT
*---------------------------------------------------------------------*
*- CSECT & COMMON - static areas, and relative address                *
*- of fields are equal to the sum of relative CSECT addr and          *
*- field offset in the CSECT.                                         *
*- DSECT - dynamic area, its position is defined by a base register   *
*- Base register # and value can change with program execution        *
*- It is up to the user to determine if it is currently valid.        *
*---------------------------------------------------------------------*
SECT     TM    S#ORG,X'10'             CSECT or COMMON ?
         BNO   DSECT                   This is DSECT
*- Set up CSECT:
         BAL   14,GETCTAB              Set up NTAB chain
         LTR   11,11
         BNZ   FIN3                    Expected to present
*        WTO   'A31ESD: CSECT not found for SYM',ROUTCDE=11
         LA    4,NOESD                 No CSECT
         B     FIN2
FIN3     SR    4,4                     "Correct CSECT"
*- Add element to NTAB for CSECT if the first:
         L     14,CTABADDR
         USING CTAB,14
**chg    CLI   C#TYPE1,C##SYM
**chg    BE    FIN2                    Already there
         MVI   C#TYPE1,C##SYM          ==> Get type
         B     FIN                     ready to add
         DROP  14                      USING
DSECT    BAL   14,GETDTAB              Set up DTAB chain
         B     FIN2                    DSECT not yet needed
*- Advance to next element:
FIN2     DS    0H
         CLI   ENDFILE,1
         BE    SYMENDA                 process reminder
         SR    6,6
         LH    6,Y#LENS                R6 = length SYM card
         LR    1,5                     current position
         LA    3,Y#INF                 start of inf
         SR    1,3                     offset to next elem from inf
         SR    6,1                     length of inf remainder
         CH    6,H20
         BL    SMALL                   remains less than 20 bytes
*- remains more than 20 bytes
         SR    6,6
         LR    7,5
         B     PROCELM
*- Remainder might contain no entire element:
SMALL    LA    8,Y#LENGTH(8)           Next card
         BCTR  6,0                     length-1 for MVC (R6>1)
         B     NEXTCARD
*- Store SYM element in NTAB:
FIN      BAL   14,GETNEWN              R11->new NTAB
         B     FIN2                    If not available
         L     14,TABREF
**chg    IC    3,0(14)                 save left byte
         ST    11,0(14)                attach element
**chg    STC   3,0(14)                 restore left byte
         USING NTAB,11
         ST    11,NTABADDR
         LA    14,N#NEXT
         ST    14,TABREF               ==> TABREF
         SR    14,14
         ST    14,N#NEXT               ==> N#NEXT
         ST    14,N#R1                 ==> N#R1
         LA    14,8
         STC   14,N#NMLN               ==> Name length <==
         IC    14,SYMTYPE1
         STC   14,N#TYPE               ==> N#TYPE
         MVC   N#NAME(8),SYMNAME       ==> N#NAME
         SR    R3,R3
         ICM   R3,B'0111',S#ADDR
**chg    L     3,S#ORG
**chg    LA    3,0(3)                  Address
         ST    3,N#ADDR                ==> N#ADDR
         LH    3,SYMLEN
         ST    3,N#SIZE                ==> N#SIZE
         STH   3,N#INT                 ==> N#INT, until user updates
         MVC   N#DIM(4),SYMKRATN       ==> N#DIM
*- Update  D#SIZE, if DSECT:
         L     14,DTABADDR
         LTR   14,14
         BZ    NODSIZE                 not a DSECT
         USING DTAB,14
         L     3,N#ADDR
         L     1,N#DIM                 Array dimension
         LTR   1,1
         BP    DSCYCLE
         LA    1,1
DSCYCLE  A     3,N#SIZE                advance to next element
         BCT   1,DSCYCLE
* R3-> End of element:
         C     3,D#SIZE
         BNH   NODSIZE
         ST    3,D#SIZE
         DROP  14                      USING
NODSIZE  DS    0H
* If type and multiplier = 0, set type EQU:
         TM    N#TYPE,X'F0'
         BO    FIN2                    not data type
         L     3,SYMKRATN
         LTR   3,3
         BNZ   FIN2                    multiplier > 0
         MVI   N#TYPE,X'F6'            type EQU
         ST    3,N#SIZE                Zero length
         STH   3,N#INT                 Zero
         B     FIN2
*---------------------------------------------------------------------*
*- End of SYM records:                                                *
*---------------------------------------------------------------------*
SYMEND   LTR   6,6                     0 or length of remainder - 1
         BZ    SYMENDX                 no remainder
         MVI   ENDFILE,1               remainder for FIN2
         LA    6,1(6)                  restore length of remainder
         STH   6,Y#LENS                save length of remainder
*- Continue processing remainder:
SYMENDA  LH    6,Y#LENS                R6= length of inf of SYM card
         LR    1,5                     Current position
         LA    3,S#REST                Start of inf
         SR    1,3                     Offset of next elem from inf
         SR    6,1                     length of inf remainder
         CH    6,H4
         BL    SYMENDX                 remains less than 4 bytes
*- Remains more than 4 bytes:
         SR    6,6
         LR    7,5
         B     PROCELM
SYMENDX  DS    0H
*---------------------------------------------------------------------*
*                                                                     *
*  Process  IDR-records CSECT (they come all together)
*  (Fill CSECT processing date)
*                                                                     *
*---------------------------------------------------------------------*
**       LA    2,PARMLIST
         L     10,D##ADDR              R10=Addr of D#
**       LA    10,0(10)                drop VL bit
         USING D#,10
         L     9,D#BUF
IDRTEST  L     11,PTABADDR             Addr  PTAB
         USING PTAB,11
         CLI   0(9),X'80'
         BNE   IDREND
         TM    2(9),X'04'              Compiler ?
         BO    IDRREC                  Process
         CLI   P#SSI,0
         BNE   IDRREAD                 SSI present do not search LKED
         TM    2(9),X'02'              LKED ?
         BZ    IDRREAD                 no
*---------------------------------------------------------------------*
*- LKED record: fill P#SSI:
*---------------------------------------------------------------------*
         MVC   P#SSI(3),15(9)
         B     IDRREAD                 Next record
*---------------------------------------------------------------------*
*  Compiler record:
*  Mark sections listed, then fill the dates
*---------------------------------------------------------------------*
IDRREC   SR    6,6
         IC    6,1(9)                  Record length
         LA    6,1(6,9)                R6= Addr of record end
         LA    5,3(9)                  R5= Addr of data in record
IDRCPRC  MVC   WCNUM(2),0(5)           CESD elem # (unaligned)
         NI    WCNUM,B'01111111'       Drop last-flag
         LH    7,WCNUM
         BAL   14,SETCTAB              Find CTAB by number
         B     IDRREAD                 if not found
         L     11,CTABADDR
         USING CTAB,11
         MVI   C#SSIFLG,C#PUTSSI       Mark C#SSI
         TM    0(5),X'80'
         BNZ   IDRCSSI                 Last in the list: fill SSI
         LA    5,2(5)
IDRNXTC  CR    5,6                     Record end ?
         BL    IDRCPRC                 no - process next element
IDRREAD  LA    R1,PARMLIST
         L     15,A$READ
         BASSM 14,15                   ***> CALL  $READ
         LTR   15,15
         BZ    IDRTEST                 Record read
         B     IDREND                  no record read
*---------------------------------------------------------------------*
*  Get and fill SSI to the marked sections:
*---------------------------------------------------------------------*
IDRCSSI  MVC   WCSSI(3),15(5)          Read part or whole SSI
         LA    7,18(5)                 Addr of end of SSI
         SR    7,6                     Length of passed remainder
         BP    IDRCSSI1                Only part of SSI in cur record
*- Usually: Whole SSI is in the current record
         LA    5,18(5)                 advance pointer
         B     IDRWSSI                 store SSI
*- Not whole SSI is in current record:
IDRCSSI1 CH    7,=H'3'
         BNL   IDRCSSI2                SSI is in the next record
*- Rare: SSI is splitted (R7<3 = length of remainder of SSI):
*        WTO 'A31ESD: Splitted SSI encountered',ROUTCDE=11
CUT      LA    R1,PARMLIST
         L     15,A$READ               Read next record
         BASSM 14,15                   ***> CALL  $READ
         LTR   15,15
         BNZ   IDREND                  no record read
         LA    5,3(7,9)                R5= Addr of SSI begin
*- Attach SSI continuation:
         LA    6,WCSSI+2
         SR    6,7                     Where to write
MORE1    IC    15,2(7,9)               Read a byte of SSI
         STC   15,0(7,6)               Write the byte
         BCT   7,MORE1                 Repeate until R7 > 0
         B     IDRCSSI3                Store SSI
*- Sometimes: whole SSI in the next record:
IDRCSSI2 SH    7,=H'3'                 SSI offset in record data
         LA    R1,PARMLIST
         L     15,A$READ
         BASSM 14,15                   ***> CALL  $READ
         LTR   15,15
         BNZ   IDREND                  no record
         LA    5,3(7,9)                R5= Addr of SSI
         MVC   WCSSI(3),0(5)           Store SSI
         LA    5,3(5)                  Advance pointer
IDRCSSI3 SR    6,6
         IC    6,1(9)                  Record length
         LA    6,1(6,9)                R6= Addr of record end
*- Store SSI to the marked CTAB:
IDRWSSI  L     11,PTABADDR             PTAB
         L     11,P#CTAB-PTAB(11)      1st CTAB
IDRCW    LTR   11,11
         BZ    IDRNXTC                 No more CTABs
         TM    C#SSIFLG,C#PUTSSI       Marked CTAB?
         BNO   IDRCWN                  CTAB not marked
         MVC   C#SSI(3),WCSSI          Copy SSI
IDRCWN   L     11,C#NEXT
         B     IDRCW                   Loop by CTAB
*-
C#SSIFLG EQU   C#SSI
C#PUTSSI EQU   X'FF'
*---------------------------------------------------------------------*
*- Fill FORTRAN-G names:                                              *
*---------------------------------------------------------------------*
IDREND   DS    0H
*IDREND   LA    1,PARMLIST
*         L     15,A$FORT
*         BALR  14,15                   ***> CALL  A31FORT
*         CH    15,H20                  TEST RC A31FORT
*         BNL   NSORT                   Table overflow
*---------------------------------------------------------------------*
*- Add A- & V-const from RLD-records:
*---------------------------------------------------------------------*
**       LA    2,PARMLIST
         LA    R1,PARMLIST
         L     15,A$OPEN
         BASSM 14,15                   ***> CALL  $OPEN
         L     9,D#BUF                 R9-> input block
         L     10,D##ADDR              R10=Addr of D#
**       LA    10,0(10)
         L     9,D#BUF
*        B     TESTRLD                 Process record:
READRLD  LA    R1,PARMLIST
         L     15,A$READ
         BASSM 14,15                   ***> CALL  $READ
         LTR   15,15
         BNZ   NSORT                   End of file
         USING RLDREC,9                Map RLD record
*- Record type:
TESTRLD  CLI   RL#TYPE,RL#RLD
         BE    PROCRLD                 RLD
         CLI   RL#TYPE,RL#CRLD
         BE    PROCRLD                 CRLD
         CLI   RL#TYPE,RL#CLAST
         BE    PROCRLD                 CRLD-last
         CLI   RL#TYPE,RL#LAST
         BNE   READRLD                 Other: skip it
PROCRLD  CLC   RL#NULL,=XL3'000000'
         BNE   READRLD                 Not RLD
         LH    6,RL#RLCNT              Data size for RLD
         LTR   6,6
         BZ    READRLD                 No RLD-data
         LA    8,RL#DATA
         AR    6,8                     Addr of RLD-data end
         DROP  8                       USING
         USING RLDATA,8
*---------------------------------------------------------------------*
*  R6=Addr of data end, R8=Addr of data
*- Process triplets: (R,P,(F,A))
*---------------------------------------------------------------------*
PROCRP   LH    7,RD#P                  Section # with reference
         BAL   14,SETCTAB              R11-> Last NTAB or CTAB
         B     READRLD                 If CTAB not found
         LA    7,RD#F                  1st element FA
         LTR   11,11
         BNZ   GETCTYP                 found
*        WTO   'A31ESD.PROCRP: ESD not found',ROUTCDE=11
         B     NSORT                   Fatal error
GETCTYP  L     4,CTABADDR
         DROP  11                      USING
         USING CTAB,4
PROCFA   CLI   C#TYPE1,C'A'
         BE    NEXTFA                  SYM present - do not need RLD
         SR    5,5
         IC    5,0(7)                  F (XXXXLLST)
         SLL   5,24
         SRL   5,28                    Keep R5='XXXX'
         CH    5,=H'1'
         BH    NEXTFA
*- Add  NTAB:
         BAL   14,GETNEWN              R11-> new NTAB
         B     NSORT                   not available
         L     14,TABREF
**chg    IC    15,0(14)                Save left byte
         ST    11,0(14)                Attach element
**chg    STC   15,0(14)                Restore left byte
         USING NTAB,11
         ST    11,NTABADDR
         LA    14,N#NEXT
         ST    14,TABREF               ==> TABREF
         SR    14,14
         ST    14,N#NEXT               ==> N#NEXT
         ST    14,N#R1                 ==> N#R1
         LA    14,8
         STC   14,N#NMLN               ==> Name length <==
         MVC   N#NAME,=CL8'        '   ==> Name (empty)
         LTR   5,5
         BZ    *+12
         MVI   N#TYPE,C'V'             ==> V type
         B     *+8
         MVI   N#TYPE,C'A'             ==> A type
         IC    5,RD#F
         SLL   5,28
         SRL   5,30                    Keep  R5='LL'
         LA    5,1(5)                  R5=R5+1= Constant length
         ST    5,N#SIZE                ==> N#SIZE
         STH   5,N#INT                 ==> N#INT
         LA    5,1
         ST    5,N#DIM                 ==> N#DIM
         SR    R5,R5
         ICM   R5,B'0111',1(R7)        RD#A = offset in the program
**       L     5,0(7)                  RD#A = offset in the program
**       LA    5,0(5)                  Cut RD#F
         S     5,C#ADDR                Offset in CSECT
         ST    5,N#ADDR                ==> N#ADDR
NEXTFA   TM    0(7),1                  Last FA for RP ?
         LA    7,4(7)                  Next FA or RP
         BNZ   PROCFA                  Not last FA
         CR    7,6
         BNL   READRLD                 End of data in record
NEXTRP   LR    8,7                     Addr of next RP
         B     PROCRP
         DROP  4                       USING CTAB
*---------------------------------------------------------------------*
*- Sort  NTABs by N#ADDR and clear C#BASE:
*---------------------------------------------------------------------*
NSORT    LA    4,PARMLIST
         L     4,4(4)                  PTAB
         USING PTAB,4
         L     5,P#CTAB                1st CTAB
         USING CTAB,5
*- Loop by CTAB, R5->*
NXTCTAB3 LTR   5,5
         BZ    SORTEND2                End of Sort
         CLI   C#TYPE,LR
         BNE   NOTENTRY                CSECT
*- Entry Point: Save C#BASE=QCTAB, add NTAB((4),NAME,ADDR):
PRENTRY  L     7,C#DTAB                Addr CSECT elem
**chg    LA    7,0(7)                  cut type
         ST    7,C#BASE                store to ENTRY.CTAB
         DROP  5                       USING CTAB
         USING CTAB,7
         L     11,C#NTAB               1st NTAB
         CLI   C#TYPE1,0               SYM present?
         BNE   GETCTAB3                SYM, SYMDB -> next CTAB
*- No SYM: create LR-element and take next CTAB:
         L     14,C#ADDR-CTAB(5)       Addr of LR
         C     14,C#ADDR               Compare to addr of CSECT
         BE    NOFICT                  equal - do not add NTAB
         LR    3,11                    save old C#NTAB
         BAL   14,GETNEWN              R11-> New NTAB (for LR)
         B     GETCTAB3     not avail: no change - not sort
         USING NTAB,11
         ST    11,C#NTAB               Attach NTAB
**chg    ST    11,SAVNTAB              Attach NTAB, save C#TYPE1
**chg    MVC   C#NTAB+1(3),SAVNTAB+1   copy 3 bytes
         XC    NTAB(N#LENGTH),NTAB     ==> clear all fields
         ST    3,N#NEXT                ==> N#NEXT
         MVC   N#NAME(8),C#NAME-CTAB(5)   ==> N#NAME for LR
         MVI   N#TYPE,Z#STMT           ==> N#TYPE
         LA    6,C#NTAB                for CSORT
         L     14,C#ADDR-CTAB(5)       Addr of LR
         S     14,C#ADDR               Offset of LR
         ST    14,N#ADDR               ==> N#ADDR
         BAL   2,SORTRUN2
         DROP  7                       USING CTAB
         USING CTAB,5
NOFICT   XC    C#DTAB(4),C#DTAB        Clear  C#DTAB
**chgT   XC    C#DTAB+1(3),C#DTAB+1    Clear  C#DTAB
         B     GETCTAB3                Next CTAB
*-
NOTENTRY XC    C#BASE,C#BASE
         LA    6,C#NTAB                Addr of pointer to NTAB chain
         L     11,C#NTAB               1st NTAB
         CLI   C#TYPE1,C'A'            Only RLD?
         BE    CSORT                   For SYM do not need dummy
         CLI   C#TYPE,0                CSECT (or COMMON)
         BNE   CSORT                   For not CSECT not need dummy
*- No NTAB for CTAB except RLD: Create dummy and take next CTAB:
PUTFICT  CLC   N#ADDR,NULL
         BE    CSORT                   NTAB with addr=0 exists
         LR    3,11                    save old C#NTAB
         BAL   14,GETNEWN              R11-> new NTAB (for dummy)
         B     CSORT                   - not available
         ST    11,C#NTAB               Attach NTAB
**chg    ST    11,SAVNTAB              Attach NTAB, save C#TYPE1
**chg    MVC   C#NTAB+1(3),SAVNTAB+1   Copy 3 bytes
         XC    NTAB(N#LENGTH),NTAB     ==> clear all fields
         ST    3,N#NEXT                ==> N#NEXT
         MVC   N#NAME,C#NAME           ==> N#NAME
         MVI   N#TYPE,Z#CSECT          ==> N#TYPE
         LTR   3,3                     If no other NTAB,
         BZ    GETCTAB3                take next CTAB, no DTAB
*-
CSORT    BAL   2,SORTRUN2              Sort NTAB for CTAB     8
*- Now Sort DTAB chains:
         L     3,C#DTAB                1st DTAB for CTAB
**chg    LA    3,0(3)                  cut C#TYPE
         USING DTAB,3
NXTDTAB3 LTR   3,3
         BZ    GETCTAB3                No more DTAB -> next CTAB
         LA    6,D#NTAB                Addr of pointer to NTAB chain
         L     11,D#NTAB               Addr of NTAB
         LTR   11,11
         BZ    GETDTAB3                No NTAB for DTAB
         BAL   2,SORTRUN2              Sort NTAB
GETDTAB3 L     3,D#NEXT                Next DTAB
         B     NXTDTAB3
*-
GETCTAB3 L     5,C#NEXT
         B     NXTCTAB3
*
*- Sort loop by passes: R6-> Addr of 1st NTAB (C#NTAB)
*
SORTRUN2 DS    0H
**chg    L     11,0(6)                 C#NTAB
**chg    ST    11,SAVNTAB              Save C#TYPE1
SORTRUN3 SR    0,0                     Clear exchange flag
         L     11,0(6)                 1st NTAB
         LTR   11,11
         BZ    NXTPASS2                No elements
         LR    7,6                     Addr 1st reference
*- Loop by NTAB in the pass:
NXTNTAB2 L     10,N#NEXT               2nd = next
         LTR   10,10
         BZ    NXTPASS2                end of pass
         DROP  11                      USING
         USING NTAB,10
         L     1,N#ADDR                addr in next
         DROP  10                      USING
         USING NTAB,11
         C     1,N#ADDR                compare to previous
         BL    EXCHANG2
         LA    7,N#NEXT                new previous
         LR    11,10                   1st = 2nd
         B     NXTNTAB2                continue by NTAB
*- Exchange elements:
EXCHANG2 ST    10,0(7)                 Ref to current
         DROP  11                      USING
         USING NTAB,10
         L     1,N#NEXT   ¢10!         old
         ST    11,N#NEXT  ¢10!         new
         LA    7,N#NEXT   ¢10!         Addr of previous reference
         DROP  10                      USING
         USING NTAB,11
         ST    1,N#NEXT   ¢11!         reference from next
         LA    0,1                     set exchange flag
         B     NXTNTAB2                11 now the 2nd
NXTPASS2 LTR   0,0
         BNZ   SORTRUN3                next pass
*- Sort end for CSECT tables
**chg    IC    11,SAVNTAB
**chg    STC   11,0(6)                 Restore C#TYPE1
         BR    2                       Exit
*=
SORTEND2 DS    0H
*        WTO   'SYM SORT ENDED',ROUTCDE=11
* Continue processing:
*=======================================
CLOSE    DS    0H
*        LA    1,PARMLIST
*        L     15,A$CLOSE
*        BASSM 14,15                   ***> CALL $CLOSE
*        LTR   15,15
*        BZ    CLOSEOK
*        WTO   'A31ESD: CLOSE FAILED',ROUTCDE=11
*        B     EXIT
*CLOSEOK  DS    0H        'A31ESD: CLOSE SUCCESSFUL',ROUTCDE=11
         B     EXIT
*======================================================================
* Subroutine for setting CTAB by number of ESD,
* coming in R7 (and kept in C#BASE).
* Output:
* R11-> Last NTAB or CTAB (if no NTAB)
* Addr of CTAB stored in CTABADDR
* If CTAB found, exit to R14+4
* If CTAB found, exit to R14
*-------------------------------------------------
*- Search for  CTAB:
SETCTAB  LA    11,PARMLIST
         L     11,4(11)                PTAB
         DROP  4,11                    USING
         USING PTAB,11
         L     11,P#CTAB               1st  CTAB
         DROP  5,11                    USING
         USING CTAB,11
TSTCNUM  C     7,C#BASE
         BE    SETCNTB                 CTAB found
         L     11,C#NEXT
         LTR   11,11
         BZ    SETCERR                 not found: R11=0
         B     TSTCNUM
*- Fill CTABADDR, DTABADDR, TABREF:
SETCNTB  ST    11,CTABADDR
         XC    DTABADDR(4),DTABADDR    clear DTABADDR
         XC    NTABADDR(4),NTABADDR    clear NTABADDR
         LA    11,C#NTAB
         ST    11,TABREF               Addr of the last reference
         L     11,CTABADDR
         CLC   C#NTAB,=F'0'            Addr of 1st NTAB=0 ?
         BE    SETCEXIT                No NTAB
         L     11,C#NTAB               1st NTAB
*- Find the last NTAB:
         DROP  11                      USING
         USING NTAB,11
TSTNTB   CLC   N#NEXT(4),=F'0'
         BE    TSTNEXIT                R11-> last NTAB
         L     11,N#NEXT
         B     TSTNTB
*- Last NTAB found: fill NTABADDR & TABREF:
TSTNEXIT ST    11,NTABADDR
         LA    11,N#NEXT
         ST    11,TABREF
         L     11,NTABADDR
SETCEXIT B     4(14)
SETCERR  BR    14
*=====================================================================
* Subroutine to set
* R11-> last NTAB or CTAB (if no NTAB)
* by CSECT name, stored in SYMNAME
* Addr of CTAB will be stored to CTABADDR
* Addr of NTAB will be stored to NTABADDR
* Addr of last reference .#NEXT stored to TABREF
* DTABADDR will be cleared
* Exit:  R14
*-------------------------------------------------
*- Search for CTAB:
GETCTAB  LA    11,PARMLIST
         L     11,4(11)                PTAB
         DROP  11                      USING
         USING PTAB,11
         L     11,P#CTAB               1st CTAB
         DROP  11                      USING
         USING CTAB,11
TSTCNAM  CLC   SYMNAME(8),C#NAME
         BE    GETCNTB                 CTAB found
         L     11,C#NEXT
         LTR   11,11
         BZ    GETCEXIT                not found: R11=0
         B     TSTCNAM
*-> Entry for known CTAB: R11->CTAB, R14->exit
*- Fill CTABADDR, DTABADDR, TABREF:
GETCNTB  ST    11,CTABADDR
         XC    DTABADDR(4),DTABADDR    clear DTABADDR
         XC    NTABADDR(4),NTABADDR    clear NTABADDR
         LA    11,C#NTAB
         ST    11,TABREF               Addr of last reference
         L     11,CTABADDR
         CLC   C#NTAB+1(3),=F'0'       Addr of 1st NTAB=0 ?
         BE    GETCEXIT                No NTAB
         L     11,C#NTAB               1st NTAB
*- Find the last NTAB:
         DROP  11                      USING
         USING NTAB,11
TSTCNTB  CLC   N#NEXT(4),=F'0'
         BE    TSTCEXIT                R11-> last NTAB
         L     11,N#NEXT
         B     TSTCNTB
*- Last NTAB found: fill NTABADDR & TABREF:
TSTCEXIT ST    11,NTABADDR
         LA    11,N#NEXT
         ST    11,TABREF
         L     11,NTABADDR
GETCEXIT BR    14
*=====================================================================
* Subroutine to set
* R11-> last NTAB or DTAB (if no NTAB)
* by DSECT name, stored in SYMNAME.
* Addr of CTAB taken from CTABADDR
* Addr of NTAB will be stored in NTABADDR
* Addr of DTAB will be stored in DTABADDR
* Addr of last reference .#NEXT stored in TABREF
* Exit:  R14
*-------------------------------------------------
GETDTAB  DS    0H
*- POICKATÓ CTAB:
         L     11,CTABADDR
         DROP  11                      USING
         USING CTAB,11
         L     11,C#DTAB               1st  DTAB
         LTR   11,11
         BNZ   TSTDNAM                 Search DTAB
*- DTAB not yet set - create DTAB chain
         L     11,CTABADDR
         LA    11,C#DTAB
         ST    11,TABREF               ==> TABREF
         DROP  11,3                    USING
         USING DTAB,11
*- New DTAB: TABREF->.#NEXT
NEWDTAB  ST    14,SAVE14#1
         BAL   14,GETNEWD              R11-> New DTAB
         B     NEWDTABX                not available
*- Attach new DTAB to DTAB chain:
         L     14,TABREF
**chg    IC    3,0(14)                 save left byte
         ST    11,0(14)                attach to the chain
**chg    STC   3,0(14)                 restore left byte
         ST    11,DTABADDR             ==> DTABADDR
         SR    14,14
         DROP  11                      USING
         USING DTAB,11
         ST    14,D#NEXT               ==> D#NEXT
         MVC   D#NAME(8),SYMNAME       ==> D#NAME
         ST    14,D#NTAB               ==> D#NTAB
         ST    14,D#BASE               ==> D#BASE
         ST    14,D#ADDR               ==> D#ADDR
         L     14,CTABADDR
         ST    14,D#CTAB               ==> D#CTAB
         LA    14,D#NTAB
         ST    14,TABREF               ==> TABREF ready
NEWDTABX L     14,SAVE14#1
         B     GETDEXIT
*- DTAB exists - search this DTAB by name:
TSTDNAM  CLC   SYMNAME(8),D#NAME
         BE    GETDNTB                 DTAB found
         CLC   D#NEXT,=F'0'
         BE    NEWDTAB1                not found: create
         L     11,D#NEXT
         B     TSTDNAM
*- DTAB not found - create new
NEWDTAB1 LA    11,D#NEXT
         ST    11,TABREF               ==>TABREF
         B     NEWDTAB
*- DTAB found: fill  DTABADDR, TABREF:
GETDNTB  ST    11,DTABADDR             ==>DTABADDR
         LA    11,D#NTAB
         ST    11,TABREF               ==> TABREF
         L     11,DTABADDR
         CLC   D#NTAB,=F'0'            Addr of 1st NTAB=0 ?
         BE    GETDEXIT                no NTAB
         L     11,D#NTAB               1st NTAB
*- Find the last NTAB:
         DROP  11                      USING
         USING NTAB,11
TSTDNTB  CLC   N#NEXT(4),=F'0'
         BE    TSTDEXIT                R11-> last NTAB
         L     11,N#NEXT
         B     TSTDNTB
*- Last NTAB found: fill NTABADDR & TABREF:
TSTDEXIT ST    11,NTABADDR
         LA    11,N#NEXT
         ST    11,TABREF               ==> TABREF
         L     11,NTABADDR
GETDEXIT BR    14
*=====================================================================
* Subroutine to get address to store new CTAB or NTAB
* HOBOGO CTAB, DTAB ILI NTAB.
* If not available, allocate more space
* Enter:    R1          -> For GETNEWV Name length
* Exit:     R14+4       -> R11= addr of NTAB element
*           R14         -> RAM not available, table not changed
*                          RC=NOSPACE
*-------------------------------------------------
GETNEWC  SAVE  (14,12)
         LA    7,C#LENGTH              CTAB element length
         B     GETAREA
GETNEWD  SAVE  (14,12)
         LA    7,D#LENGTH              DTAB element length
         B     GETAREA
*- NTAB element with variable name length (R1=name length):
GETNEWV  SAVE  (14,12)
         LA    7,N#LENGTH-8(1)         NTAB elem length and name
         B     GETAREA
*- Standard NTAB size:
GETNEWN  DS    0H
GETNEW   SAVE  (14,12)
         LA    7,N#LENGTH              defaul element length
*- R7=element length required. Check if space available in P#DATA:
GETAREA  DS    0H
         L     11,PTABADDR             Addr PTAB
         DROP  11                      USING
         USING PTAB,11
*- Get free element: R7=requested length
GETELEM  L     1,P#AFREE               R1=Addr of new element
         LA    2,0(7,1)                Addr of end of new element
         C     2,P#AEND                End of P#DATA
         BH    GETERROR                P#DATA overflow
         ST    2,P#AFREE               ==> advance P#AFREE
*- normal exit:
GETEXIT  SR    15,15
         ST    1,64(13)                replace R11 by R1
         L     3,P#CTAB
         LTR   3,3
         BNZ   GETEXIT0                P#CTAB exists- continue
*- Initialize LAST*:
         LA    3,P#CTAB
         ST    3,LASTCTAB              Store address
         SR    3,3
         ST    3,LASTNTAB
GETEXIT0 LM    14,12,12(13)
         SR    15,15
         B     4(14)                   normal end
*- Error exit:
GETERROR DS    0H
         LA    15,NOSPACE
         ST    15,RC
         LM    14,12,12(13)
         BR    14                      error exit
         DROP  11                      USING
*---------------------------------------------------------------------
* C O N S T A N T S  and  D S E C T S
*---------------------------------------------------------------------
$CLSOFFS EQU   80                      X'50' offset of $CLOSE ep
$REDOFFS EQU   48                      X'30' offset of $READ ep
*A$FORT   DC    V(A31FORT)
NULL     DC    F'0'
VL       EQU   X'80'                   VL-BIT
NO$OPEN  EQU   24
NOSPACE  EQU   20
NOTOPEN  EQU   16
NOESD    EQU   12
OVERLAY  EQU   8
SCTR     EQU   12
NOSYM    EQU   4
MVCS     MVC   0(0,7),0(5)
MVCN     MVC   SYMNAME(0),0(5)
H20      DC    H'20'
H9       DC    H'9'
H8       DC    H'8'
H4       DC    H'4'
SYMTYPE  DC    C'CXBXFHEDAYSVPZL'
#BLANKS  DC    8C' '
         DS    0F
MAXH     DC    X'00007FFF'             Max halfword
         LTORG
*---------------------------------------------------------------------
*- PDS ENTRY:
PDS24    DSECT
         DS    F                       add offset 4 bytes
         IHAPDS DSECT=NO
*---------------------------------------------------------------------
*- Program table:
PTAB     DSECT
         COPY  $PTAB
*---------------------------------------------------------------------
*- $OPEN parameter mapping
D#       DSECT
D#RC     DS    F                       return code
D#DSN    DS    CL44                    DSNAME
D#MEM    DS    CL8                     MEMBER
D#VOL    DS    CL6                     VOLSER
D#LEN    DS    H                       record length
D#DCB    DS    F                       DCB address
D#BUF    DS    F                       Buffer address
D#LAST   DS    F                       Data length in buffer
D#RECA   DS    F                       Record addr in buffer
*---------------------------------------------------------------------
*- Element of CTAB:
CTAB     DSECT
         COPY  $CTAB
*---------------------------------------------------------------------
*- Element of DTAB:
DTAB     DSECT
         COPY  $DTAB
*---------------------------------------------------------------------
*- Element of NTAB:
NTAB     DSECT
         COPY  $NTAB
*---------------------------------------------------------------------
*- SYM record header:
Y#       DSECT
Y#X02    DS    XL1
Y#SYM    DS    CL3'SYM'
Y#BL6    DS    CL6' '
Y#LEN    DS    XL2                     Unaligned
Y#BL4    DS    CL4' '
Y#INF    DS    0H                      Information (data)
Y#LENGTH EQU   80                      SYM record size
*---------------------------------------------------------------------
*- SYM element header:
S#       DSECT
S#ORG    DS    XL1                     element organization
S#ADDR   DS    AL3                     relative address
S#NAME   DS    0H                      name and other fields.
*---------------------------------------------------------------------
*- ESD element:
E#       DSECT
E#NAME   DS    CL8                     Name
E#TYPE   DS    XL1                     Type
E#ADDR   DS    AL3                     CSECT addr
E#SEG    DS    XL1                     Overlay segment #
E#LEN    DS    AL3                     Section length or
*                                      # of free element (for EP)
E#LENGTH EQU   *-E#                    ESD element size (16 bytes)
*---------------------------------------------------------------------
*- WORKAREA:
$WRK     DSECT
         DS    18F                     SAVEAREA
SYMNAME  DS    CL8                     Part of SYM element
SYMKRATN DS    F
SYMLEN   DS    H
SYMTYPE1 DS    X
PARMLIST DS    5F                      Copy of parmlist
D##ADDR  EQU   PARMLIST
PTABADDR EQU   PARMLIST+4
*- If module is searched by address:
W#NAME   DS    CL8                     Name of left nearest entry
W#ADDR   DS    A                       It's address
W#LEN    DS    H                       Length of variable
W#OFS    DS    H                       Variable offset from neighbor
W#TYPE   DS    X
         ORG   W#TYPE
W#MLEN   DS    F                       Module name or data multiplier
*-
Y#LENS   DS    H                       Copy of Y#LEN
S#REST   DS    CL20                   Copy of remainder SYM for NEXTBLK
SECTADDR DS    F
SECTSIZE DS    F
SECTNAME DS    CL8
PARMNAME DS    CL8
*- DOBABKI DLù A31:
LASTCTAB DS    A
LASTNTAB DS    A
SYMFOUND DS    F                       Flag SYM present
CTABADDR DS    A                       Addr of current CTAB
DTABADDR DS    A                       Addr of current DTAB or 0
NTABADDR DS    A                       Wrk: save addr of NTAB
SAVE14#1 DS    F                       Wrk: save R14
TABREF   DS    A                       Addr of last .#NEXT
RC       DS    F
OVERFL   DS    F                       Mask to clear segment #
SAVNTAB  DS    A
WCNUM    DS    H
WCSSI    DS    3X
ENDFILE  DS    X
W#DEBUG  DS    X                       Flag debug from A3CVT
SAVETYP  DS    X                       Save left byte
A$OPEN   DS    A
A$READ   DS    A
A$CLOSE  DS    A
RETC     DS    F
         DS    0D
$WRKLEN  EQU   *-$WRK                  workarea size
         COPY  $RLD
         COPY  $RLDATA
         END
//*
//LKED    EXEC PGM=HEWLKED,PARM='NCAL,MAP,RMOD=ANY,AMOD=31,RENT',
//        COND=(8,LE)
//*YSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST    <== hlq.LOAD
//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(A31ESD) <== *.LOAD
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)
//*
